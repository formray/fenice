# M3.1 Sprint Design — Two-Phase Builder + Polish

**Date:** 2026-02-23
**Author:** Giuseppe Albrizio + Claude Opus 4.6
**Status:** Approved
**Branch:** feat/m3.1-two-phase-builder

## Context

M3 shipped a working AI Builder: prompt → Claude API → generated files → PR. The pipeline works end-to-end but has two problems:

1. **No user control** — Claude generates everything in one shot (~6 minutes). If the plan is wrong, you waste the full generation time before discovering it.
2. **No feedback loop** — The user submits a prompt and waits. No way to preview, edit, or reject what Claude intends to build before it writes code.

## Goal

Split the builder into a two-phase pipeline: **Plan** then **Generate**. The user sees a manifest of files Claude intends to create, can edit or remove entries, then approves to trigger code generation. This gives control, reduces wasted time, and makes the builder feel collaborative rather than fire-and-forget.

## Decision: Approach A — Two-Phase Single Job

A single job traverses both phases. One jobId, one WebSocket stream, one DB document. The job pauses at `plan_ready` and resumes on explicit user approval.

Alternatives considered:
- **B. Two Separate Endpoints** — Rejected: two jobIds complicate client state, duplicate logic.
- **C. Client-Side Planning** — Rejected: exposes API key to browser, breaks server-side security model.

## 1. Pipeline + Status Model

### New status flow

```
queued → planning → plan_ready → [WAIT FOR USER] → generating → writing_files → validating → creating_pr → completed
                                        ↓
                                    rejected (terminal)
```

### New statuses

| Status | Meaning |
|--------|---------|
| `planning` | Claude is analyzing the prompt and producing a file manifest |
| `plan_ready` | Manifest ready, job waiting for user approve/reject |
| `rejected` | User rejected the plan (terminal state) |

Status enum grows from 8 to 11 values.

### Manifest schema

```typescript
BuilderPlanFile {
  path: string;           // e.g. "src/schemas/product.schema.ts"
  type: 'schema' | 'model' | 'service' | 'route' | 'test';
  action: 'create' | 'modify';
  description: string;    // "Zod schema for Product with CRUD types"
}

BuilderPlan {
  files: BuilderPlanFile[];
  summary: string;        // 1-2 sentence summary of what will be generated
}
```

Saved in the job document under the `plan` field.

### Planning call to Claude

- System prompt: dedicated `BUILDER_PLAN_PROMPT` (compact, no code patterns)
- User message: context + prompt
- Response: structured JSON output (no tool use)
- Model: `claude-sonnet-4-20250514`, `max_tokens: 1024`
- Estimated: ~5-10 seconds

### Constrained generation

The approved plan is injected into the generation prompt as a binding constraint:

```
## Approved Plan — generate ONLY these files

1. src/schemas/product.schema.ts (create) — Zod schema for Product
2. src/models/product.model.ts (create) — Mongoose model
...

Do NOT create files outside this plan. Do NOT skip files in this plan.
```

This also reduces generation time because Claude has a precise target.

## 2. API + Backend Changes

### Endpoints

| Endpoint | Method | Change |
|----------|--------|--------|
| `POST /builder/generate` | Existing | Pipeline now stops at `plan_ready` |
| `POST /builder/jobs/:id/approve` | **New** | Accepts `{ plan: BuilderPlan }`, restarts pipeline from `generating` |
| `POST /builder/jobs/:id/reject` | **New** | Sets status to `rejected` (terminal) |
| `GET /builder/jobs/:id` | Existing | Response now includes `plan` field |

### File changes (server)

| File | Change |
|------|--------|
| `src/schemas/builder.schema.ts` | Add `BuilderPlanFileSchema`, `BuilderPlanSchema`, `BuilderApproveSchema`, new status enum values |
| `src/models/builder-job.model.ts` | Add `plan` field to Mongoose schema |
| `src/services/builder.service.ts` | Split `executePipeline` into `executePlanning()` (stops at `plan_ready`) and `executeGeneration()` (resumes from approve). New `approve()` and `reject()` methods |
| `src/services/builder/code-generator.ts` | New `generatePlan()` function (Claude without tool use, JSON output). Existing `generateCode()` receives plan as parameter, injects into prompt |
| `src/services/builder/prompt-templates.ts` | New `BUILDER_PLAN_PROMPT`. Generation prompt enriched with approved plan constraint |
| `src/routes/builder.routes.ts` | New `approve` and `reject` routes with RBAC admin + kill switch |
| `src/services/builder/world-notifier.ts` | New status messages for `planning`, `plan_ready`, `rejected` |

## 3. Client Changes

### Builder store — new state and actions

```typescript
// New fields
plan: BuilderPlanFile[] | null;    // manifest from Claude
summary: string | null;            // plan summary

// New actions
setPlan(plan, summary)             // on plan_ready
updatePlanFile(index, changes)     // inline edit of a file entry
removePlanFile(index)              // remove file from plan
approveJob()                       // POST approve with (edited) plan
rejectJob()                        // POST reject
```

### Builder API — new functions

```typescript
approveBuilderJob(token, jobId, plan)   // POST /api/v1/builder/jobs/:id/approve
rejectBuilderJob(token, jobId)          // POST /api/v1/builder/jobs/:id/reject
```

### Prompt Bar UI — Plan Review section

When `status === 'plan_ready'`, the panel shows:

1. **Summary** — 1-2 sentences from Claude describing the plan
2. **Editable file list** — each entry shows:
   - Type badge (`schema`, `model`, `service`, `route`, `test`)
   - Path (monospace)
   - Description (editable inline input)
   - X button to remove the file
3. **Action row** — two buttons:
   - **Approve & Generate** (primary blue)
   - **Reject** (ghost/outline red)

Panel expands vertically (max-height ~300px with scroll). Width stays at 420px.

### WebSocket integration

The `builder.progress` delta with `status: 'plan_ready'` does NOT carry the full plan (could be large). Instead, the client does a `GET /builder/jobs/:id` fetch when it sees `plan_ready` to retrieve the complete plan. More robust, avoids oversized WebSocket messages.

### World delta payload extension

```typescript
BuilderProgressPayload {
  jobId: string;
  status: BuilderJobStatus;
  message: string;
  detail?: string;          // tool activity during generation
}
```

No change to the delta payload structure — plan data comes via REST fetch.

## 4. Glowy Loading Bar

Replace the current static progress bar with an animated effect:

1. **Fill bar** — advances per step, with an animated `linear-gradient` that scrolls left-to-right in a loop
2. **Glow pulse** — `box-shadow` that pulses sinusoidally. Blue during `planning`/`generating`, green on `completed`
3. **Shimmer overlay** — semi-transparent white highlight sweeping across the bar (subtle barber-pole effect)

All done with inline styles + a single `<style>` tag injected in the component for `@keyframes`. No external dependencies.

**During `planning`** (~5-10s): indeterminate shimmer loop (no percentage). Communicates "analyzing".

**During `generating`** (~minutes): bar advances per step with pulsing glow + activity log below.

## 5. Context Reduction (Generation Speed)

The context reader currently loads ~30KB+ of context per generation call. Optimizations:

- Trim CLAUDE.md to relevant blocks only (Tech Stack, Conventions, Naming) — ~3KB vs ~15KB
- Skip full OpenAPI spec in generation phase (the plan already constrains what to generate)
- Use 1 example file per type instead of 4 full files

Estimated: ~40-50% fewer input tokens, faster generation.

## 6. Job Timeout

No timeout currently exists. If Claude stalls or the pipeline crashes, the job stays in `generating` forever.

Add a 10-minute TTL: a timeout guard in the pipeline that sets `failed` with `code: 'TIMEOUT'` if no progress in 10 minutes.

## Sprint Scope Summary

| Item | Type | Effort |
|------|------|--------|
| Two-phase pipeline (plan → approve → generate) | Feature | Large |
| Approve/Reject endpoints | Feature | Medium |
| Plan review UI in prompt bar (editable manifest) | Feature | Medium |
| Glowy animated loading bar | Polish | Small |
| Context reduction for faster generation | Optimization | Small |
| Job timeout (10 min TTL) | Reliability | Small |
| New statuses in schemas + world delta + client types | Plumbing | Small |

## Future Notes (NOT this sprint)

- **Scalability:** Replace fire-and-forget `void this.executePipeline()` with a proper job queue (Bull/BullMQ with Redis). Worker processes handle pipeline execution independently.
- **Speed:** Cache context bundle across jobs (invalidate on file changes). Stream Claude responses for faster perceived time.
- **Multi-user:** Job ownership, permissions for approve/reject, concurrent job limits per user.
- **Smoothness:** Optimistic UI updates, skeleton loaders during planning, typewriter effect for summary text.

These are annotated for future sprint planning but explicitly deferred.

## Verification

1. `npm run validate` — lint + typecheck + test pass (server: 536+ tests)
2. `cd client && npm run typecheck && npm run test` — client passes (154+ tests)
3. Manual test: submit prompt → see plan in ~5-10s → edit file list → approve → generation completes → file list shown
4. Manual test: submit prompt → see plan → reject → job marked rejected
5. Verify glowy loading bar animates during planning and generating phases
6. Verify job timeout triggers after 10 minutes of no progress
