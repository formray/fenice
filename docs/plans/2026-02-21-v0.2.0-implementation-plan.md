# v0.2.0 — Advanced Backend Features Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Implement 10 production features (RBAC, rate limiting, pagination, search, email verification, password reset, file upload, WebSocket, validation middleware, API versioning) organized in 3 dependency waves.

**Architecture:** Middleware-First strategy. Wave 1 builds cross-cutting middleware (validation, RBAC, rate limiting). Wave 2 adds API enhancements (pagination, search, versioning). Wave 3 builds feature modules (email verification, password reset, file upload, WebSocket) that depend on the middleware from Wave 1.

**Tech Stack:** Hono 4.x, Zod v4, Mongoose v9, TypeScript 5.x (strict mode), Vitest 4.x, fast-check, ESM with `.js` extensions.

**Design Doc:** `docs/plans/2026-02-21-v0.2.0-advanced-backend-design.md`

**Working Directory:** `/Users/giuseppealbriziowork/Repos/Formray/fenice`

---

## Important Conventions

Before implementing anything, know these rules:

1. **ESM imports** — All local imports MUST end in `.js`: `import { foo } from './bar.js';`
2. **Strict TypeScript** — `exactOptionalPropertyTypes: true` means optional props need `| undefined`: `refreshToken?: string | undefined`
3. **Zod v4** — Use `.issues` not `.errors` on ZodError
4. **Lazy-init** — Never call `loadEnv()` at module-level in middleware or route files (breaks tests). Use lazy-init pattern (see `src/middleware/auth.ts` and `src/routes/auth.routes.ts`).
5. **File naming** — `kebab-case.ts` (e.g., `rate-limiter.ts`, `query-builder.ts`)
6. **Schemas** — `PascalCase` with `Schema` suffix
7. **Commits** — Conventional Commits: `feat:`, `fix:`, `test:`, `refactor:`
8. **Tests** — Vitest with `globals: true`. Property tests use fast-check. Filter generated emails through `z.string().email().safeParse()`.
9. **AuthEnv type** — Routes that need auth context use `AuthEnv = { Variables: { userId: string; email: string; role: string; requestId: string } }`

---

## Wave 1: Cross-Cutting Middleware

### Task 1: New Error Classes (RateLimitError, UploadError)

**Files:**
- Modify: `src/utils/errors.ts`
- Modify: `tests/unit/utils/errors.test.ts`

**Step 1: Add tests for new error classes**

Add to `tests/unit/utils/errors.test.ts`:

```typescript
describe('RateLimitError', () => {
  it('should create error with 429 status and retryAfter', () => {
    const error = new RateLimitError(60);
    expect(error.statusCode).toBe(429);
    expect(error.code).toBe('RATE_LIMIT_EXCEEDED');
    expect(error.retryAfter).toBe(60);
    expect(error.message).toBe('Too many requests');
  });
});

describe('UploadError', () => {
  it('should create error with 400 status', () => {
    const error = new UploadError('File too large');
    expect(error.statusCode).toBe(400);
    expect(error.code).toBe('UPLOAD_ERROR');
    expect(error.message).toBe('File too large');
  });
});
```

**Step 2: Run tests to verify they fail**

Run: `npm run test -- tests/unit/utils/errors.test.ts`
Expected: FAIL — `RateLimitError` and `UploadError` not defined

**Step 3: Implement new error classes**

Add to `src/utils/errors.ts`:

```typescript
export class RateLimitError extends AppError {
  constructor(public readonly retryAfter: number) {
    super(429, 'RATE_LIMIT_EXCEEDED', 'Too many requests');
  }
}

export class UploadError extends AppError {
  constructor(message = 'Upload failed') {
    super(400, 'UPLOAD_ERROR', message);
  }
}
```

**Step 4: Update error handler to support 429**

In `src/middleware/errorHandler.ts`, update the status code type union to include `429`:

```typescript
err.statusCode as 400 | 401 | 403 | 404 | 429 | 500
```

Also add RateLimitError-specific handling to set `Retry-After` header:

```typescript
if (err instanceof AppError) {
  if ('retryAfter' in err) {
    c.header('Retry-After', String((err as RateLimitError).retryAfter));
  }
  // ... existing response logic
}
```

Import `RateLimitError` at top of errorHandler.ts.

**Step 5: Run tests to verify they pass**

Run: `npm run test -- tests/unit/utils/errors.test.ts`
Expected: PASS

**Step 6: Commit**

```bash
git add src/utils/errors.ts src/middleware/errorHandler.ts tests/unit/utils/errors.test.ts
git commit -m "feat: add RateLimitError and UploadError classes"
```

---

### Task 2: Crypto Utility (token generation + SHA-256 hashing)

**Files:**
- Create: `src/utils/crypto.ts`
- Create: `tests/unit/utils/crypto.test.ts`

**Step 1: Write tests**

Create `tests/unit/utils/crypto.test.ts`:

```typescript
import { describe, it, expect } from 'vitest';
import { generateToken, hashToken } from '../../src/utils/crypto.js';

describe('crypto utils', () => {
  describe('generateToken', () => {
    it('should generate a 64-char hex string (32 bytes)', () => {
      const token = generateToken();
      expect(token).toHaveLength(64);
      expect(token).toMatch(/^[0-9a-f]{64}$/);
    });

    it('should generate unique tokens', () => {
      const tokens = new Set(Array.from({ length: 10 }, () => generateToken()));
      expect(tokens.size).toBe(10);
    });
  });

  describe('hashToken', () => {
    it('should produce consistent SHA-256 hash', () => {
      const token = 'test-token';
      const hash1 = hashToken(token);
      const hash2 = hashToken(token);
      expect(hash1).toBe(hash2);
    });

    it('should produce 64-char hex hash', () => {
      const hash = hashToken('any-input');
      expect(hash).toHaveLength(64);
      expect(hash).toMatch(/^[0-9a-f]{64}$/);
    });

    it('should produce different hashes for different inputs', () => {
      expect(hashToken('a')).not.toBe(hashToken('b'));
    });
  });
});
```

**Step 2: Run tests to verify they fail**

Run: `npm run test -- tests/unit/utils/crypto.test.ts`
Expected: FAIL — module not found

**Step 3: Implement**

Create `src/utils/crypto.ts`:

```typescript
import { randomBytes, createHash } from 'node:crypto';

export function generateToken(bytes = 32): string {
  return randomBytes(bytes).toString('hex');
}

export function hashToken(token: string): string {
  return createHash('sha256').update(token).digest('hex');
}
```

**Step 4: Run tests to verify they pass**

Run: `npm run test -- tests/unit/utils/crypto.test.ts`
Expected: PASS

**Step 5: Commit**

```bash
git add src/utils/crypto.ts tests/unit/utils/crypto.test.ts
git commit -m "feat: add crypto utility for token generation and SHA-256 hashing"
```

---

### Task 3: Request Validation Middleware

**Files:**
- Create: `src/middleware/validate.ts`
- Create: `tests/unit/middleware/validate.test.ts`

**Step 1: Write tests**

Create `tests/unit/middleware/validate.test.ts`:

```typescript
import { describe, it, expect } from 'vitest';
import { Hono } from 'hono';
import { z } from 'zod';
import { validate } from '../../src/middleware/validate.js';

describe('validate middleware', () => {
  it('should pass with valid query params', async () => {
    const app = new Hono();
    app.get('/test', validate({ query: z.object({ name: z.string() }) }), (c) => {
      return c.json({ ok: true });
    });

    const res = await app.request('/test?name=foo');
    expect(res.status).toBe(200);
  });

  it('should return 400 with invalid query params', async () => {
    const app = new Hono();
    app.get('/test', validate({ query: z.object({ count: z.coerce.number().positive() }) }), (c) => {
      return c.json({ ok: true });
    });

    const res = await app.request('/test?count=-1');
    expect(res.status).toBe(400);
    const body = await res.json();
    expect(body.error.code).toBe('VALIDATION_ERROR');
  });

  it('should pass with valid JSON body', async () => {
    const app = new Hono();
    app.post('/test', validate({ body: z.object({ email: z.string().email() }) }), (c) => {
      return c.json({ ok: true });
    });

    const res = await app.request('/test', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ email: 'test@example.com' }),
    });
    expect(res.status).toBe(200);
  });

  it('should return 400 with invalid JSON body', async () => {
    const app = new Hono();
    app.post('/test', validate({ body: z.object({ email: z.string().email() }) }), (c) => {
      return c.json({ ok: true });
    });

    const res = await app.request('/test', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ email: 'not-an-email' }),
    });
    expect(res.status).toBe(400);
  });
});
```

**Step 2: Run tests to verify they fail**

Run: `npm run test -- tests/unit/middleware/validate.test.ts`
Expected: FAIL

**Step 3: Implement**

Create `src/middleware/validate.ts`:

```typescript
import { createMiddleware } from 'hono/factory';
import { type ZodType, ZodError } from 'zod';
import { ValidationError } from '../utils/errors.js';

interface ValidateSchemas {
  body?: ZodType;
  query?: ZodType;
  params?: ZodType;
}

export function validate(schemas: ValidateSchemas) {
  return createMiddleware(async (c, next) => {
    const errors: { field?: string; message: string }[] = [];

    if (schemas.query) {
      const queryObj = Object.fromEntries(new URL(c.req.url).searchParams);
      const result = schemas.query.safeParse(queryObj);
      if (!result.success) {
        for (const issue of (result.error as ZodError).issues) {
          errors.push({ field: issue.path.join('.'), message: issue.message });
        }
      }
    }

    if (schemas.body) {
      try {
        const body = await c.req.json();
        const result = schemas.body.safeParse(body);
        if (!result.success) {
          for (const issue of (result.error as ZodError).issues) {
            errors.push({ field: issue.path.join('.'), message: issue.message });
          }
        }
      } catch {
        errors.push({ message: 'Invalid JSON body' });
      }
    }

    if (schemas.params) {
      const result = schemas.params.safeParse(c.req.param());
      if (!result.success) {
        for (const issue of (result.error as ZodError).issues) {
          errors.push({ field: issue.path.join('.'), message: issue.message });
        }
      }
    }

    if (errors.length > 0) {
      throw new ValidationError(errors);
    }

    await next();
  });
}
```

**Step 4: Run tests to verify they pass**

Run: `npm run test -- tests/unit/middleware/validate.test.ts`
Expected: PASS

**Step 5: Commit**

```bash
git add src/middleware/validate.ts tests/unit/middleware/validate.test.ts
git commit -m "feat: add generic Zod request validation middleware"
```

---

### Task 4: RBAC Middleware

**Files:**
- Create: `src/middleware/rbac.ts`
- Create: `tests/unit/middleware/rbac.test.ts`

**Step 1: Write tests**

Create `tests/unit/middleware/rbac.test.ts`:

```typescript
import { describe, it, expect } from 'vitest';
import { Hono } from 'hono';
import { requireRole, requireRoles, ROLE_HIERARCHY } from '../../src/middleware/rbac.js';

function createApp(middleware: ReturnType<typeof requireRole>) {
  const app = new Hono();
  // Simulate auth middleware setting role
  app.use('*', async (c, next) => {
    c.set('role', c.req.header('x-test-role') ?? 'user');
    await next();
  });
  app.get('/test', middleware, (c) => c.json({ ok: true }));
  return app;
}

describe('RBAC middleware', () => {
  describe('ROLE_HIERARCHY', () => {
    it('should have all 6 roles with ascending values', () => {
      expect(ROLE_HIERARCHY['user']).toBeLessThan(ROLE_HIERARCHY['vendor']);
      expect(ROLE_HIERARCHY['vendor']).toBeLessThan(ROLE_HIERARCHY['client']);
      expect(ROLE_HIERARCHY['client']).toBeLessThan(ROLE_HIERARCHY['employee']);
      expect(ROLE_HIERARCHY['employee']).toBeLessThan(ROLE_HIERARCHY['admin']);
      expect(ROLE_HIERARCHY['admin']).toBeLessThan(ROLE_HIERARCHY['superAdmin']);
    });
  });

  describe('requireRole', () => {
    it('should allow superAdmin to access admin-only route', async () => {
      const app = createApp(requireRole('admin'));
      const res = await app.request('/test', { headers: { 'x-test-role': 'superAdmin' } });
      expect(res.status).toBe(200);
    });

    it('should allow admin to access admin-only route', async () => {
      const app = createApp(requireRole('admin'));
      const res = await app.request('/test', { headers: { 'x-test-role': 'admin' } });
      expect(res.status).toBe(200);
    });

    it('should deny user access to admin-only route', async () => {
      const app = createApp(requireRole('admin'));
      const res = await app.request('/test', { headers: { 'x-test-role': 'user' } });
      expect(res.status).toBe(403);
    });

    it('should deny employee access to admin-only route', async () => {
      const app = createApp(requireRole('admin'));
      const res = await app.request('/test', { headers: { 'x-test-role': 'employee' } });
      expect(res.status).toBe(403);
    });

    it('should allow any authenticated user for user-level route', async () => {
      const app = createApp(requireRole('user'));
      const res = await app.request('/test', { headers: { 'x-test-role': 'user' } });
      expect(res.status).toBe(200);
    });
  });

  describe('requireRoles', () => {
    it('should allow listed roles (OR logic)', async () => {
      const app = createApp(requireRoles(['admin', 'editor'] as never));
      const res = await app.request('/test', { headers: { 'x-test-role': 'admin' } });
      expect(res.status).toBe(200);
    });

    it('should deny unlisted roles', async () => {
      const app = createApp(requireRoles(['admin'] as never));
      const res = await app.request('/test', { headers: { 'x-test-role': 'user' } });
      expect(res.status).toBe(403);
    });
  });
});
```

**Step 2: Run tests to verify they fail**

Run: `npm run test -- tests/unit/middleware/rbac.test.ts`
Expected: FAIL

**Step 3: Implement**

Create `src/middleware/rbac.ts`:

```typescript
import { createMiddleware } from 'hono/factory';
import { ForbiddenError } from '../utils/errors.js';

type Role = 'superAdmin' | 'admin' | 'employee' | 'client' | 'vendor' | 'user';

export const ROLE_HIERARCHY: Record<Role, number> = {
  superAdmin: 60,
  admin: 50,
  employee: 40,
  client: 30,
  vendor: 20,
  user: 10,
};

export function requireRole(minRole: Role) {
  return createMiddleware(async (c, next) => {
    const userRole = (c.get('role') as string) || 'user';
    const userLevel = ROLE_HIERARCHY[userRole as Role] ?? 0;
    const requiredLevel = ROLE_HIERARCHY[minRole];

    if (userLevel < requiredLevel) {
      throw new ForbiddenError('Insufficient permissions');
    }

    await next();
  });
}

export function requireRoles(roles: Role[]) {
  return createMiddleware(async (c, next) => {
    const userRole = (c.get('role') as string) || 'user';

    if (!roles.includes(userRole as Role)) {
      throw new ForbiddenError('Insufficient permissions');
    }

    await next();
  });
}
```

**Step 4: Run tests to verify they pass**

Run: `npm run test -- tests/unit/middleware/rbac.test.ts`
Expected: PASS

**Step 5: Refactor delete route to use RBAC middleware**

In `src/routes/user.routes.ts`, replace the inline admin check:

```typescript
// BEFORE (in deleteUserRoute handler):
// if (role !== 'admin' && role !== 'superAdmin') {
//   throw new ForbiddenError('Forbidden — admin only');
// }

// AFTER: Apply requireRole middleware before the handler
// Import requireRole from '../middleware/rbac.js'
```

The inline check in the delete handler should be removed. Instead, apply RBAC in the middleware chain in `src/index.ts` or directly on the route.

**Step 6: Run all tests**

Run: `npm run test`
Expected: All passing

**Step 7: Commit**

```bash
git add src/middleware/rbac.ts tests/unit/middleware/rbac.test.ts src/routes/user.routes.ts
git commit -m "feat: add RBAC middleware with role hierarchy"
```

---

### Task 5: Rate Limiting Middleware

**Files:**
- Create: `src/middleware/rate-limiter.ts`
- Create: `tests/unit/middleware/rate-limiter.test.ts`

**Step 1: Write tests**

Create `tests/unit/middleware/rate-limiter.test.ts`:

```typescript
import { describe, it, expect, beforeEach, vi } from 'vitest';
import { Hono } from 'hono';
import { rateLimiter, MemoryRateLimitStore } from '../../src/middleware/rate-limiter.js';

describe('rate limiter', () => {
  describe('MemoryRateLimitStore', () => {
    let store: MemoryRateLimitStore;

    beforeEach(() => {
      store = new MemoryRateLimitStore(60_000); // 60s window
    });

    it('should increment count from 0 to 1', async () => {
      const result = await store.increment('key1');
      expect(result.count).toBe(1);
    });

    it('should increment count on subsequent calls', async () => {
      await store.increment('key1');
      const result = await store.increment('key1');
      expect(result.count).toBe(2);
    });

    it('should track separate keys independently', async () => {
      await store.increment('key1');
      await store.increment('key1');
      const result = await store.increment('key2');
      expect(result.count).toBe(1);
    });

    it('should reset count', async () => {
      await store.increment('key1');
      await store.increment('key1');
      await store.reset('key1');
      const result = await store.increment('key1');
      expect(result.count).toBe(1);
    });
  });

  describe('rateLimiter middleware', () => {
    it('should allow requests under the limit', async () => {
      const app = new Hono();
      app.use('*', rateLimiter({ windowMs: 60_000, max: 5 }));
      app.get('/test', (c) => c.json({ ok: true }));

      const res = await app.request('/test');
      expect(res.status).toBe(200);
      expect(res.headers.get('X-RateLimit-Limit')).toBe('5');
    });

    it('should return 429 when limit exceeded', async () => {
      const app = new Hono();
      app.use('*', rateLimiter({ windowMs: 60_000, max: 2 }));
      app.get('/test', (c) => c.json({ ok: true }));

      await app.request('/test');
      await app.request('/test');
      const res = await app.request('/test');
      expect(res.status).toBe(429);
    });

    it('should set rate limit headers', async () => {
      const app = new Hono();
      app.use('*', rateLimiter({ windowMs: 60_000, max: 10 }));
      app.get('/test', (c) => c.json({ ok: true }));

      const res = await app.request('/test');
      expect(res.headers.get('X-RateLimit-Limit')).toBe('10');
      expect(res.headers.get('X-RateLimit-Remaining')).toBe('9');
      expect(res.headers.get('X-RateLimit-Reset')).toBeDefined();
    });
  });
});
```

**Step 2: Run tests to verify they fail**

Run: `npm run test -- tests/unit/middleware/rate-limiter.test.ts`
Expected: FAIL

**Step 3: Implement**

Create `src/middleware/rate-limiter.ts`:

```typescript
import { createMiddleware } from 'hono/factory';
import { RateLimitError } from '../utils/errors.js';

export interface RateLimitStore {
  increment(key: string): Promise<{ count: number; resetAt: number }>;
  reset(key: string): Promise<void>;
}

export class MemoryRateLimitStore implements RateLimitStore {
  private store = new Map<string, { count: number; resetAt: number }>();
  private cleanupTimer: ReturnType<typeof setInterval> | undefined;

  constructor(private readonly windowMs: number) {
    // Cleanup expired entries every 60s
    this.cleanupTimer = setInterval(() => this.cleanup(), 60_000);
    // Don't block process exit
    if (this.cleanupTimer.unref) {
      this.cleanupTimer.unref();
    }
  }

  async increment(key: string): Promise<{ count: number; resetAt: number }> {
    const now = Date.now();
    const existing = this.store.get(key);

    if (!existing || now >= existing.resetAt) {
      const entry = { count: 1, resetAt: now + this.windowMs };
      this.store.set(key, entry);
      return entry;
    }

    existing.count += 1;
    return existing;
  }

  async reset(key: string): Promise<void> {
    this.store.delete(key);
  }

  private cleanup(): void {
    const now = Date.now();
    for (const [key, entry] of this.store) {
      if (now >= entry.resetAt) {
        this.store.delete(key);
      }
    }
  }

  destroy(): void {
    if (this.cleanupTimer) {
      clearInterval(this.cleanupTimer);
    }
    this.store.clear();
  }
}

interface RateLimiterOptions {
  windowMs?: number;
  max?: number;
  store?: RateLimitStore;
  keyGenerator?: (c: { req: { header: (name: string) => string | undefined }; get: (key: string) => unknown }) => string;
}

export function rateLimiter(options: RateLimiterOptions = {}) {
  const {
    windowMs = 60_000,
    max = 100,
    keyGenerator = (c) => {
      const userId = c.get('userId') as string | undefined;
      return userId ?? c.req.header('x-forwarded-for') ?? 'unknown';
    },
  } = options;

  const store = options.store ?? new MemoryRateLimitStore(windowMs);

  return createMiddleware(async (c, next) => {
    const key = keyGenerator(c);
    const { count, resetAt } = await store.increment(key);

    c.header('X-RateLimit-Limit', String(max));
    c.header('X-RateLimit-Remaining', String(Math.max(0, max - count)));
    c.header('X-RateLimit-Reset', String(Math.ceil(resetAt / 1000)));

    if (count > max) {
      const retryAfter = Math.ceil((resetAt - Date.now()) / 1000);
      throw new RateLimitError(retryAfter);
    }

    await next();
  });
}
```

**Step 4: Run tests to verify they pass**

Run: `npm run test -- tests/unit/middleware/rate-limiter.test.ts`
Expected: PASS

**Step 5: Commit**

```bash
git add src/middleware/rate-limiter.ts tests/unit/middleware/rate-limiter.test.ts
git commit -m "feat: add rate limiting middleware with abstract store interface"
```

---

### Task 6: Wire Wave 1 Middleware into App

**Files:**
- Modify: `src/index.ts`
- Modify: `src/config/env.ts`

**Step 1: Add rate limit env vars to EnvSchema**

In `src/config/env.ts`, add optional rate limit config:

```typescript
// Rate Limiting
RATE_LIMIT_WINDOW_MS: z.coerce.number().default(60_000),
RATE_LIMIT_MAX_REQUESTS: z.coerce.number().default(100),
```

**Step 2: Update src/index.ts**

Add rate limiting middleware to the middleware chain:

```typescript
import { rateLimiter } from './middleware/rate-limiter.js';

// After existing global middleware, before auth middleware:
// Rate limiting — auth routes have stricter limits
app.use('/api/v1/auth/*', rateLimiter({ windowMs: 60_000, max: 10 }));
app.use('/api/v1/*', rateLimiter()); // default 100/min
```

**Step 3: Run all tests**

Run: `npm run test`
Expected: All passing

**Step 4: Run lint + typecheck**

Run: `npm run lint && npm run typecheck`
Expected: Clean

**Step 5: Commit**

```bash
git add src/index.ts src/config/env.ts
git commit -m "feat: wire rate limiting and env config for Wave 1 middleware"
```

---

## Wave 2: API Enhancement

### Task 7: Pagination Utility

**Files:**
- Create: `src/utils/pagination.ts`
- Create: `tests/unit/utils/pagination.test.ts`
- Modify: `src/schemas/common.schema.ts`

**Step 1: Update common schema with cursor pagination**

In `src/schemas/common.schema.ts`, add:

```typescript
export const CursorPaginationSchema = z.object({
  cursor: z.string().optional(),
  limit: z.coerce.number().int().positive().max(100).default(20),
  sort: z.string().default('createdAt'),
  order: z.enum(['asc', 'desc']).default('desc'),
});

export const PaginatedResponseSchema = z.object({
  data: z.array(z.unknown()),
  pagination: z.object({
    hasNext: z.boolean(),
    nextCursor: z.string().nullable(),
    total: z.number().optional(),
  }),
});

export type CursorPagination = z.infer<typeof CursorPaginationSchema>;
export type PaginatedResponse<T> = {
  data: T[];
  pagination: {
    hasNext: boolean;
    nextCursor: string | null;
    total?: number;
  };
};
```

**Step 2: Write pagination utility tests**

Create `tests/unit/utils/pagination.test.ts`:

```typescript
import { describe, it, expect } from 'vitest';
import { encodeCursor, decodeCursor } from '../../src/utils/pagination.js';

describe('pagination utils', () => {
  describe('encodeCursor / decodeCursor', () => {
    it('should encode and decode cursor round-trip', () => {
      const cursor = { id: '507f1f77bcf86cd799439011', sortValue: '2026-01-01T00:00:00.000Z' };
      const encoded = encodeCursor(cursor);
      const decoded = decodeCursor(encoded);
      expect(decoded).toEqual(cursor);
    });

    it('should return null for invalid cursor', () => {
      const decoded = decodeCursor('not-valid-base64-json');
      expect(decoded).toBeNull();
    });

    it('should return null for undefined cursor', () => {
      const decoded = decodeCursor(undefined);
      expect(decoded).toBeNull();
    });

    it('should produce base64 string', () => {
      const encoded = encodeCursor({ id: 'abc', sortValue: 'xyz' });
      expect(typeof encoded).toBe('string');
      // Should be valid base64
      expect(() => Buffer.from(encoded, 'base64')).not.toThrow();
    });
  });
});
```

**Step 3: Run tests to verify they fail**

Run: `npm run test -- tests/unit/utils/pagination.test.ts`
Expected: FAIL

**Step 4: Implement pagination utility**

Create `src/utils/pagination.ts`:

```typescript
interface CursorData {
  id: string;
  sortValue: string;
}

export function encodeCursor(data: CursorData): string {
  return Buffer.from(JSON.stringify(data)).toString('base64');
}

export function decodeCursor(cursor: string | undefined | null): CursorData | null {
  if (!cursor) return null;
  try {
    const json = Buffer.from(cursor, 'base64').toString('utf-8');
    const parsed = JSON.parse(json) as CursorData;
    if (typeof parsed.id !== 'string' || typeof parsed.sortValue !== 'string') {
      return null;
    }
    return parsed;
  } catch {
    return null;
  }
}
```

**Step 5: Run tests to verify they pass**

Run: `npm run test -- tests/unit/utils/pagination.test.ts`
Expected: PASS

**Step 6: Commit**

```bash
git add src/schemas/common.schema.ts src/utils/pagination.ts tests/unit/utils/pagination.test.ts
git commit -m "feat: add cursor-based pagination utility and schemas"
```

---

### Task 8: Query Builder Utility

**Files:**
- Create: `src/utils/query-builder.ts`
- Create: `tests/unit/utils/query-builder.test.ts`
- Modify: `src/schemas/user.schema.ts`

**Step 1: Add UserQuerySchema to user schema**

In `src/schemas/user.schema.ts`, add:

```typescript
export const UserQuerySchema = z.object({
  search: z.string().optional(),
  role: RoleEnum.optional(),
  active: z.coerce.boolean().optional(),
  createdAfter: z.string().datetime().optional(),
  createdBefore: z.string().datetime().optional(),
});

export type UserQuery = z.infer<typeof UserQuerySchema>;
```

**Step 2: Write query builder tests**

Create `tests/unit/utils/query-builder.test.ts`:

```typescript
import { describe, it, expect } from 'vitest';
import { buildUserFilter } from '../../src/utils/query-builder.js';

describe('query-builder', () => {
  describe('buildUserFilter', () => {
    it('should return empty filter for empty params', () => {
      const filter = buildUserFilter({});
      expect(filter).toEqual({});
    });

    it('should build search regex filter', () => {
      const filter = buildUserFilter({ search: 'giuseppe' });
      expect(filter).toHaveProperty('$or');
      expect(filter['$or']).toHaveLength(3); // email, username, fullName
    });

    it('should build exact role filter', () => {
      const filter = buildUserFilter({ role: 'admin' });
      expect(filter).toEqual({ role: 'admin' });
    });

    it('should build active boolean filter', () => {
      const filter = buildUserFilter({ active: true });
      expect(filter).toEqual({ active: true });
    });

    it('should build date range filter', () => {
      const filter = buildUserFilter({
        createdAfter: '2026-01-01T00:00:00.000Z',
        createdBefore: '2026-12-31T00:00:00.000Z',
      });
      expect(filter).toHaveProperty('createdAt');
    });

    it('should combine multiple filters', () => {
      const filter = buildUserFilter({ role: 'admin', active: true, search: 'test' });
      expect(filter).toHaveProperty('role');
      expect(filter).toHaveProperty('active');
      expect(filter).toHaveProperty('$or');
    });
  });
});
```

**Step 3: Run tests to verify they fail**

Run: `npm run test -- tests/unit/utils/query-builder.test.ts`
Expected: FAIL

**Step 4: Implement query builder**

Create `src/utils/query-builder.ts`:

```typescript
import type { FilterQuery } from 'mongoose';

interface UserFilterParams {
  search?: string;
  role?: string;
  active?: boolean;
  createdAfter?: string;
  createdBefore?: string;
}

export function buildUserFilter(params: UserFilterParams): FilterQuery<unknown> {
  const filter: Record<string, unknown> = {};

  if (params.search) {
    const regex = new RegExp(params.search, 'i');
    filter['$or'] = [
      { email: { $regex: regex } },
      { username: { $regex: regex } },
      { fullName: { $regex: regex } },
    ];
  }

  if (params.role) {
    filter['role'] = params.role;
  }

  if (params.active !== undefined) {
    filter['active'] = params.active;
  }

  if (params.createdAfter || params.createdBefore) {
    const dateFilter: Record<string, Date> = {};
    if (params.createdAfter) {
      dateFilter['$gte'] = new Date(params.createdAfter);
    }
    if (params.createdBefore) {
      dateFilter['$lte'] = new Date(params.createdBefore);
    }
    filter['createdAt'] = dateFilter;
  }

  return filter as FilterQuery<unknown>;
}
```

**Step 5: Run tests to verify they pass**

Run: `npm run test -- tests/unit/utils/query-builder.test.ts`
Expected: PASS

**Step 6: Commit**

```bash
git add src/schemas/user.schema.ts src/utils/query-builder.ts tests/unit/utils/query-builder.test.ts
git commit -m "feat: add query builder utility and user query schema"
```

---

### Task 9: User List Endpoint with Pagination & Search

**Files:**
- Modify: `src/services/user.service.ts`
- Modify: `src/routes/user.routes.ts`

**Step 1: Add findAll method to UserService**

In `src/services/user.service.ts`, add:

```typescript
import type { FilterQuery } from 'mongoose';
import type { PaginatedResponse } from '../schemas/common.schema.js';
import type { User } from '../schemas/user.schema.js';
import { decodeCursor, encodeCursor } from '../utils/pagination.js';

async findAll(
  filter: FilterQuery<unknown>,
  options: { cursor?: string; limit?: number; sort?: string; order?: 'asc' | 'desc' }
): Promise<PaginatedResponse<UserDocument>> {
  const { cursor, limit = 20, sort = 'createdAt', order = 'desc' } = options;
  const cursorData = decodeCursor(cursor);

  const query: FilterQuery<unknown> = { ...filter };

  if (cursorData) {
    const direction = order === 'desc' ? '$lt' : '$gt';
    query['$or'] = [
      { [sort]: { [direction]: cursorData.sortValue } },
      { [sort]: cursorData.sortValue, _id: { [direction]: cursorData.id } },
    ];
  }

  const sortObj: Record<string, 1 | -1> = {
    [sort]: order === 'desc' ? -1 : 1,
    _id: order === 'desc' ? -1 : 1,
  };

  const users = await UserModel.find(query).sort(sortObj).limit(limit + 1);

  const hasNext = users.length > limit;
  if (hasNext) users.pop();

  const lastUser = users[users.length - 1];
  const nextCursor = hasNext && lastUser
    ? encodeCursor({
        id: lastUser._id.toString(),
        sortValue: String(lastUser.get(sort)),
      })
    : null;

  return {
    data: users,
    pagination: { hasNext, nextCursor },
  };
}
```

**Step 2: Add GET /users list route**

In `src/routes/user.routes.ts`, add a new `listUsersRoute` before existing routes:

```typescript
import { CursorPaginationSchema, PaginatedResponseSchema } from '../schemas/common.schema.js';
import { UserQuerySchema } from '../schemas/user.schema.js';
import { buildUserFilter } from '../utils/query-builder.js';

const listUsersRoute = createRoute({
  method: 'get',
  path: '/users',
  tags: ['Users'],
  summary: 'List users with pagination and filtering',
  security: [{ Bearer: [] }],
  request: {
    query: CursorPaginationSchema.merge(UserQuerySchema),
  },
  responses: {
    200: {
      description: 'Paginated user list',
      content: {
        'application/json': {
          schema: z.object({
            data: z.array(UserSchema),
            pagination: z.object({
              hasNext: z.boolean(),
              nextCursor: z.string().nullable(),
            }),
          }),
        },
      },
    },
  },
});

userRouter.openapi(listUsersRoute, async (c) => {
  const { cursor, limit, sort, order, ...filterParams } = c.req.valid('query');
  const filter = buildUserFilter(filterParams);
  const result = await userService.findAll(filter, { cursor, limit, sort, order });
  return c.json({
    data: result.data.map(serializeUser),
    pagination: result.pagination,
  }, 200);
});
```

**NOTE:** You need to also add auth middleware for `/api/v1/users` (exact path, not just `/api/v1/users/*`). In `src/index.ts`, update the auth middleware line to cover the list endpoint too. The simplest way: the existing `app.use('/api/v1/users/*', authMiddleware)` already covers `/api/v1/users/*` but `/api/v1/users` (no trailing path) may need an additional line. Test and adjust.

**Step 3: Run all tests**

Run: `npm run test`
Expected: All passing

**Step 4: Run lint + typecheck**

Run: `npm run lint && npm run typecheck`
Expected: Clean

**Step 5: Commit**

```bash
git add src/services/user.service.ts src/routes/user.routes.ts src/index.ts
git commit -m "feat: add user list endpoint with cursor pagination and search"
```

---

### Task 10: API Versioning Infrastructure

**Files:**
- Modify: `src/index.ts`
- Create: `tests/unit/middleware/api-version.test.ts`

**Step 1: Write test for version detection**

Create `tests/unit/middleware/api-version.test.ts`:

```typescript
import { describe, it, expect } from 'vitest';
import { Hono } from 'hono';
import { apiVersion } from '../../src/middleware/api-version.js';

describe('apiVersion middleware', () => {
  it('should extract v1 from /api/v1/users', async () => {
    const app = new Hono();
    app.use('*', apiVersion);
    app.get('/api/v1/users', (c) => c.json({ version: c.get('apiVersion') }));

    const res = await app.request('/api/v1/users');
    const body = await res.json();
    expect(body.version).toBe('v1');
  });

  it('should default to v1 for paths without version', async () => {
    const app = new Hono();
    app.use('*', apiVersion);
    app.get('/health', (c) => c.json({ version: c.get('apiVersion') }));

    const res = await app.request('/health');
    const body = await res.json();
    expect(body.version).toBe('v1');
  });
});
```

**Step 2: Run tests to verify they fail**

Run: `npm run test -- tests/unit/middleware/api-version.test.ts`
Expected: FAIL

**Step 3: Implement**

Create `src/middleware/api-version.ts`:

```typescript
import { createMiddleware } from 'hono/factory';

export const apiVersion = createMiddleware(async (c, next) => {
  const match = c.req.path.match(/\/api\/(v\d+)\//);
  c.set('apiVersion', match?.[1] ?? 'v1');
  await next();
});
```

**Step 4: Wire into app**

In `src/index.ts`, add after other global middleware:

```typescript
import { apiVersion } from './middleware/api-version.js';

app.use('/api/*', apiVersion);
```

**Step 5: Run tests to verify they pass**

Run: `npm run test -- tests/unit/middleware/api-version.test.ts`
Expected: PASS

**Step 6: Commit**

```bash
git add src/middleware/api-version.ts tests/unit/middleware/api-version.test.ts src/index.ts
git commit -m "feat: add API versioning middleware infrastructure"
```

---

## Wave 3: Feature Modules

### Task 11: User Model Updates for Email Verification

**Files:**
- Modify: `src/models/user.model.ts`
- Modify: `src/schemas/user.schema.ts`

**Step 1: Add new fields to Mongoose schema**

In `src/models/user.model.ts`, add to the schema definition:

```typescript
emailVerified: {
  type: Boolean,
  default: false,
},
emailVerificationToken: {
  type: String,
  select: false, // Don't return in queries by default
},
emailVerificationExpires: Date,
```

Update the `UserDocument` interface:

```typescript
export interface UserDocument extends Omit<User, 'id'>, Document {
  password: string;
  refreshToken?: string | undefined;
  resetPasswordToken?: string | undefined;
  resetPasswordExpires?: Date | undefined;
  emailVerified: boolean;
  emailVerificationToken?: string | undefined;
  emailVerificationExpires?: Date | undefined;
  comparePassword(candidatePassword: string): Promise<boolean>;
}
```

Update the `toJSON` transform to also delete:

```typescript
delete ret['emailVerificationToken'];
delete ret['emailVerificationExpires'];
```

**Step 2: Add emailVerified to Zod UserSchema**

In `src/schemas/user.schema.ts`, add to `UserSchema`:

```typescript
emailVerified: z.boolean().default(false),
```

**Step 3: Run all tests**

Run: `npm run test`
Expected: May need to update some tests that assert on user shape. Fix as needed.

**Step 4: Commit**

```bash
git add src/models/user.model.ts src/schemas/user.schema.ts
git commit -m "feat: add email verification fields to user model"
```

---

### Task 12: Auth Schema Updates (Verification + Reset)

**Files:**
- Modify: `src/schemas/auth.schema.ts`

**Step 1: Add new schemas**

In `src/schemas/auth.schema.ts`, add:

```typescript
export const VerifyEmailSchema = z.object({
  token: z.string().min(1),
});

export const RequestPasswordResetSchema = z.object({
  email: z.string().email(),
});

export const ResetPasswordSchema = z.object({
  token: z.string().min(1),
  newPassword: z.string().min(8).max(128),
});

export type VerifyEmail = z.infer<typeof VerifyEmailSchema>;
export type RequestPasswordReset = z.infer<typeof RequestPasswordResetSchema>;
export type ResetPassword = z.infer<typeof ResetPasswordSchema>;
```

**Step 2: Add schema tests**

Add validation tests to existing schema test patterns or create `tests/unit/schemas/auth.schema.test.ts`.

**Step 3: Run tests**

Run: `npm run test`
Expected: PASS

**Step 4: Commit**

```bash
git add src/schemas/auth.schema.ts tests/unit/schemas/auth.schema.test.ts
git commit -m "feat: add email verification and password reset schemas"
```

---

### Task 13: Email Verification Flow (Service + Routes)

**Files:**
- Modify: `src/services/auth.service.ts`
- Modify: `src/routes/auth.routes.ts`
- Modify: `src/adapters/index.ts` (make adapters accessible)

**Step 1: Update AuthService with verification methods**

Add to `AuthService`:

```typescript
import { generateToken, hashToken } from '../utils/crypto.js';
import type { EmailAdapter } from '../adapters/index.js';

// Constructor now accepts emailAdapter
constructor(
  private readonly jwtSecret: string,
  private readonly jwtRefreshSecret: string,
  private readonly accessExpiry: string,
  private readonly refreshExpiry: string,
  private readonly emailAdapter?: EmailAdapter,
  private readonly clientUrl?: string,
) {}

async verifyEmail(token: string): Promise<void> {
  const hashedToken = hashToken(token);
  const user = await UserModel.findOne({
    emailVerificationToken: hashedToken,
    emailVerificationExpires: { $gt: new Date() },
  }).select('+emailVerificationToken');

  if (!user) throw new NotAuthorizedError('Invalid or expired verification token');

  user.emailVerified = true;
  user.emailVerificationToken = undefined;
  user.emailVerificationExpires = undefined;
  await user.save();
}

async resendVerification(userId: string): Promise<void> {
  const user = await UserModel.findById(userId);
  if (!user) throw new NotFoundError('User not found');
  if (user.emailVerified) throw new AppError(400, 'ALREADY_VERIFIED', 'Email already verified');

  const token = generateToken();
  user.emailVerificationToken = hashToken(token);
  user.emailVerificationExpires = new Date(Date.now() + 24 * 60 * 60 * 1000); // 24h
  await user.save();

  if (this.emailAdapter) {
    await this.emailAdapter.send({
      to: user.email,
      subject: 'Verify your email — FENICE',
      html: `<p>Verify your email: <a href="${this.clientUrl}/verify-email?token=${token}">Click here</a></p>`,
    });
  }
}
```

Also update `signup()` to generate email verification token and send email.

**Step 2: Update login to check emailVerified**

In `login()` method, after credential check:

```typescript
if (!user.emailVerified) {
  throw new AppError(403, 'EMAIL_NOT_VERIFIED', 'Please verify your email before logging in');
}
```

**Step 3: Add routes**

In `src/routes/auth.routes.ts`, add:

- `GET /auth/verify-email` — query param `token`
- `POST /auth/resend-verification` — requires auth

**Step 4: Update getAuthService() to pass emailAdapter**

```typescript
function getAuthService(): AuthService {
  if (!authService) {
    const env = loadEnv();
    const adapters = createAdapters();
    authService = new AuthService(
      env.JWT_SECRET, env.JWT_REFRESH_SECRET,
      env.JWT_ACCESS_EXPIRY, env.JWT_REFRESH_EXPIRY,
      adapters.email, env.CLIENT_URL,
    );
  }
  return authService;
}
```

**Step 5: Run all tests**

Run: `npm run test`
Expected: Some integration tests for auth may need updating (login now requires emailVerified). Update test fixtures accordingly.

**Step 6: Commit**

```bash
git add src/services/auth.service.ts src/routes/auth.routes.ts src/adapters/index.ts
git commit -m "feat: add email verification flow (signup, verify, resend)"
```

---

### Task 14: Password Reset Flow

**Files:**
- Modify: `src/services/auth.service.ts`
- Modify: `src/routes/auth.routes.ts`

**Step 1: Add password reset methods to AuthService**

```typescript
async requestPasswordReset(email: string): Promise<void> {
  const user = await UserModel.findOne({ email });
  // Always return success (don't leak email existence)
  if (!user) return;

  const token = generateToken();
  user.resetPasswordToken = hashToken(token);
  user.resetPasswordExpires = new Date(Date.now() + 60 * 60 * 1000); // 1h
  await user.save();

  if (this.emailAdapter) {
    await this.emailAdapter.send({
      to: user.email,
      subject: 'Reset your password — FENICE',
      html: `<p>Reset password: <a href="${this.clientUrl}/reset-password?token=${token}">Click here</a></p>`,
    });
  }
}

async resetPassword(token: string, newPassword: string): Promise<void> {
  const hashedToken = hashToken(token);
  const user = await UserModel.findOne({
    resetPasswordToken: hashedToken,
    resetPasswordExpires: { $gt: new Date() },
  });

  if (!user) throw new NotAuthorizedError('Invalid or expired reset token');

  user.password = newPassword; // pre-save hook will hash
  user.resetPasswordToken = undefined;
  user.resetPasswordExpires = undefined;
  user.refreshToken = undefined; // Force re-login on all devices
  await user.save();
}
```

**Step 2: Add routes**

In `src/routes/auth.routes.ts`, add:

- `POST /auth/request-password-reset` — body: `{ email }`
- `POST /auth/reset-password` — body: `{ token, newPassword }`

Both routes return `SuccessResponseSchema` to avoid leaking information.

**Step 3: Run all tests**

Run: `npm run test`
Expected: PASS

**Step 4: Commit**

```bash
git add src/services/auth.service.ts src/routes/auth.routes.ts
git commit -m "feat: add password reset flow (request + reset)"
```

---

### Task 15: Upload Schema

**Files:**
- Create: `src/schemas/upload.schema.ts`
- Create: `tests/unit/schemas/upload.schema.test.ts`

**Step 1: Write schema tests**

Create `tests/unit/schemas/upload.schema.test.ts`:

```typescript
import { describe, it, expect } from 'vitest';
import { InitUploadSchema, CompleteUploadSchema } from '../../src/schemas/upload.schema.js';

describe('upload schemas', () => {
  describe('InitUploadSchema', () => {
    it('should accept valid upload init', () => {
      const result = InitUploadSchema.safeParse({
        filename: 'photo.jpg',
        contentType: 'image/jpeg',
        totalSize: 5_000_000,
      });
      expect(result.success).toBe(true);
    });

    it('should reject file over 100MB', () => {
      const result = InitUploadSchema.safeParse({
        filename: 'huge.mp4',
        contentType: 'video/mp4',
        totalSize: 200_000_000,
      });
      expect(result.success).toBe(false);
    });

    it('should reject missing filename', () => {
      const result = InitUploadSchema.safeParse({
        contentType: 'image/jpeg',
        totalSize: 1000,
      });
      expect(result.success).toBe(false);
    });
  });
});
```

**Step 2: Run tests to verify they fail**

Run: `npm run test -- tests/unit/schemas/upload.schema.test.ts`
Expected: FAIL

**Step 3: Implement schema**

Create `src/schemas/upload.schema.ts`:

```typescript
import { z } from 'zod';

const MAX_FILE_SIZE = 104_857_600; // 100MB
const CHUNK_SIZE = 5_242_880; // 5MB

const ALLOWED_MIME_TYPES = [
  'image/jpeg', 'image/png', 'image/gif', 'image/webp', 'image/svg+xml',
  'video/mp4', 'video/webm', 'video/quicktime',
  'application/pdf',
  'application/msword',
  'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
  'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
  'application/vnd.openxmlformats-officedocument.presentationml.presentation',
];

export const InitUploadSchema = z.object({
  filename: z.string().min(1).max(255),
  contentType: z.string().min(1),
  totalSize: z.number().int().positive().max(MAX_FILE_SIZE),
});

export const InitUploadResponseSchema = z.object({
  uploadId: z.string(),
  chunkSize: z.number(),
  totalChunks: z.number(),
  expiresAt: z.string().datetime(),
});

export const ChunkParamsSchema = z.object({
  uploadId: z.string().min(1),
  index: z.coerce.number().int().min(0),
});

export const ChunkResponseSchema = z.object({
  uploaded: z.number(),
  totalChunks: z.number(),
  progress: z.string(),
});

export const CompleteUploadSchema = z.object({
  uploadId: z.string().min(1),
});

export const CompleteUploadResponseSchema = z.object({
  fileId: z.string(),
  fileUrl: z.string(),
  filename: z.string(),
  contentType: z.string(),
  size: z.number(),
  createdAt: z.string().datetime(),
});

export type InitUpload = z.infer<typeof InitUploadSchema>;
export type ChunkParams = z.infer<typeof ChunkParamsSchema>;
export type CompleteUpload = z.infer<typeof CompleteUploadSchema>;

export { MAX_FILE_SIZE, CHUNK_SIZE, ALLOWED_MIME_TYPES };
```

**Step 4: Run tests to verify they pass**

Run: `npm run test -- tests/unit/schemas/upload.schema.test.ts`
Expected: PASS

**Step 5: Commit**

```bash
git add src/schemas/upload.schema.ts tests/unit/schemas/upload.schema.test.ts
git commit -m "feat: add file upload schemas with size and type validation"
```

---

### Task 16: Upload Service

**Files:**
- Create: `src/services/upload.service.ts`
- Modify: `src/config/env.ts`

**Step 1: Add upload env vars**

In `src/config/env.ts`, add:

```typescript
UPLOAD_MAX_SIZE_BYTES: z.coerce.number().default(104_857_600),
UPLOAD_CHUNK_SIZE_BYTES: z.coerce.number().default(5_242_880),
UPLOAD_SESSION_TIMEOUT_MS: z.coerce.number().default(3_600_000),
UPLOAD_MAX_CONCURRENT: z.coerce.number().default(3),
```

**Step 2: Implement upload service**

Create `src/services/upload.service.ts`:

The service manages upload sessions in-memory (Map), tracks chunks, and uses `StorageAdapter` for actual file storage. Key methods:

- `initUpload(userId, metadata)` → creates session, returns uploadId + chunkSize + totalChunks
- `uploadChunk(uploadId, index, data)` → stores chunk via adapter
- `completeUpload(uploadId)` → assembles chunks, returns file metadata
- `cancelUpload(uploadId)` → cleanup chunks + session

Include session timeout cleanup with `setInterval` (similar to rate limiter pattern).

**Step 3: Commit**

```bash
git add src/services/upload.service.ts src/config/env.ts
git commit -m "feat: add chunked upload service with session management"
```

---

### Task 17: Upload Routes

**Files:**
- Create: `src/routes/upload.routes.ts`
- Modify: `src/index.ts`

**Step 1: Implement upload routes**

Create `src/routes/upload.routes.ts` with 4 endpoints:

- `POST /upload/init` — auth required, rate limited
- `PUT /upload/:uploadId/chunk/:index` — auth required, binary body
- `POST /upload/:uploadId/complete` — auth required
- `DELETE /upload/:uploadId` — auth required (owner or admin)

Follow existing route patterns: `createRoute()` with Zod schemas, `OpenAPIHono<AuthEnv>`.

**Step 2: Mount in index.ts**

```typescript
import { uploadRouter } from './routes/upload.routes.js';

app.use('/api/v1/upload/*', authMiddleware);
app.use('/api/v1/upload/*', rateLimiter({ windowMs: 60_000, max: 5 }));
app.route('/api/v1', uploadRouter);
```

**Step 3: Run lint + typecheck + tests**

Run: `npm run validate`
Expected: Clean

**Step 4: Commit**

```bash
git add src/routes/upload.routes.ts src/index.ts
git commit -m "feat: add chunked file upload endpoints"
```

---

### Task 18: WebSocket Schema

**Files:**
- Create: `src/schemas/ws.schema.ts`
- Create: `tests/unit/schemas/ws.schema.test.ts`

**Step 1: Write tests**

Test that client and server message schemas validate correctly:

```typescript
import { describe, it, expect } from 'vitest';
import { ClientMessageSchema, ServerMessageSchema } from '../../src/schemas/ws.schema.js';

describe('WebSocket schemas', () => {
  it('should validate join_room client message', () => {
    const result = ClientMessageSchema.safeParse({ type: 'join_room', roomId: 'room-1' });
    expect(result.success).toBe(true);
  });

  it('should validate chat_message client message', () => {
    const result = ClientMessageSchema.safeParse({
      type: 'chat_message', roomId: 'room-1', content: 'hello',
    });
    expect(result.success).toBe(true);
  });

  it('should reject unknown message type', () => {
    const result = ClientMessageSchema.safeParse({ type: 'unknown' });
    expect(result.success).toBe(false);
  });
});
```

**Step 2: Implement schema**

Create `src/schemas/ws.schema.ts` with discriminated unions for client and server messages.

**Step 3: Run tests, commit**

```bash
git add src/schemas/ws.schema.ts tests/unit/schemas/ws.schema.test.ts
git commit -m "feat: add WebSocket message schemas"
```

---

### Task 19: WebSocket Connection Manager

**Files:**
- Create: `src/ws/manager.ts`
- Create: `tests/unit/ws/manager.test.ts`

**Step 1: Write tests**

Test WsManager with mock WebSocket objects:

```typescript
import { describe, it, expect, vi, beforeEach } from 'vitest';
import { WsManager } from '../../src/ws/manager.js';

function mockWs() {
  return { send: vi.fn(), close: vi.fn(), readyState: 1 };
}

describe('WsManager', () => {
  let manager: WsManager;

  beforeEach(() => {
    manager = new WsManager();
  });

  it('should add and track connection', () => {
    const ws = mockWs();
    manager.addConnection('user1', ws as never);
    expect(manager.isConnected('user1')).toBe(true);
  });

  it('should remove connection', () => {
    const ws = mockWs();
    manager.addConnection('user1', ws as never);
    manager.removeConnection('user1');
    expect(manager.isConnected('user1')).toBe(false);
  });

  it('should manage rooms', () => {
    const ws = mockWs();
    manager.addConnection('user1', ws as never);
    manager.joinRoom('user1', 'room-A');
    expect(manager.getRoomMembers('room-A')).toContain('user1');
  });

  it('should broadcast to room', () => {
    const ws1 = mockWs();
    const ws2 = mockWs();
    manager.addConnection('user1', ws1 as never);
    manager.addConnection('user2', ws2 as never);
    manager.joinRoom('user1', 'room-A');
    manager.joinRoom('user2', 'room-A');

    manager.broadcast('room-A', { type: 'notification', title: 'test', body: 'msg' });
    expect(ws1.send).toHaveBeenCalled();
    expect(ws2.send).toHaveBeenCalled();
  });

  it('should send to specific user', () => {
    const ws = mockWs();
    manager.addConnection('user1', ws as never);
    manager.sendTo('user1', { type: 'pong' });
    expect(ws.send).toHaveBeenCalled();
  });

  it('should cleanup rooms on disconnect', () => {
    const ws = mockWs();
    manager.addConnection('user1', ws as never);
    manager.joinRoom('user1', 'room-A');
    manager.removeConnection('user1');
    expect(manager.getRoomMembers('room-A')).not.toContain('user1');
  });
});
```

**Step 2: Implement WsManager**

Create `src/ws/manager.ts` with the full connection/room management.

**Step 3: Run tests, commit**

```bash
git add src/ws/manager.ts tests/unit/ws/manager.test.ts
git commit -m "feat: add WebSocket connection manager with room support"
```

---

### Task 20: WebSocket Auth

**Files:**
- Create: `src/ws/auth.ts`
- Create: `tests/unit/ws/auth.test.ts`

**Step 1: Implement WebSocket JWT verification**

Create `src/ws/auth.ts`:

```typescript
import jwt from 'jsonwebtoken';

interface WsAuthPayload {
  userId: string;
  email: string;
  role: string;
}

export function verifyWsToken(token: string, secret: string): WsAuthPayload | null {
  try {
    const payload = jwt.verify(token, secret) as WsAuthPayload;
    if (!payload.userId || !payload.email || !payload.role) return null;
    return payload;
  } catch {
    return null;
  }
}
```

**Step 2: Write tests and verify**

**Step 3: Commit**

```bash
git add src/ws/auth.ts tests/unit/ws/auth.test.ts
git commit -m "feat: add WebSocket JWT authentication"
```

---

### Task 21: WebSocket Message Handlers

**Files:**
- Create: `src/ws/handlers.ts`

**Step 1: Implement message handlers**

Create `src/ws/handlers.ts`:

Handles incoming client messages by type (join_room, leave_room, chat_message, ping). Uses WsManager for room operations and broadcasting. Validates messages with Zod schema before processing.

**Step 2: Commit**

```bash
git add src/ws/handlers.ts
git commit -m "feat: add WebSocket message handlers"
```

---

### Task 22: WebSocket Route + Upgrade

**Files:**
- Create: `src/routes/ws.routes.ts`
- Modify: `src/index.ts`

**Step 1: Implement WebSocket upgrade route**

Create `src/routes/ws.routes.ts` using Hono's WebSocket support:

```typescript
import { Hono } from 'hono';
import { createBunWebSocket } from 'hono/bun'; // or node adapter
import { WsManager } from '../ws/manager.js';
import { verifyWsToken } from '../ws/auth.js';
import { handleMessage } from '../ws/handlers.js';

// Use upgradeWebSocket from @hono/node-server or hono/bun
```

The exact WebSocket adapter depends on Hono's Node.js WebSocket support. Check `@hono/node-server` docs for `createNodeWebSocket()`.

**Step 2: Mount in index.ts**

```typescript
import { wsRouter } from './routes/ws.routes.js';
app.route('/api/v1', wsRouter);
```

**Step 3: Add WebSocket env vars to config**

In `src/config/env.ts`:

```typescript
WS_HEARTBEAT_INTERVAL_MS: z.coerce.number().default(30_000),
WS_HEARTBEAT_TIMEOUT_MS: z.coerce.number().default(10_000),
WS_MESSAGE_RATE_LIMIT: z.coerce.number().default(60),
```

**Step 4: Run lint + typecheck + tests**

Run: `npm run validate`

**Step 5: Commit**

```bash
git add src/routes/ws.routes.ts src/index.ts src/config/env.ts
git commit -m "feat: add WebSocket upgrade route with JWT auth"
```

---

### Task 23: Update MCP Endpoint

**Files:**
- Modify: `src/routes/mcp.routes.ts`

**Step 1: Add new tools to MCP discovery**

Update the MCP endpoint to include new v0.2.0 tools:

- `user_list` — with pagination/filter params
- `auth_verify_email`, `auth_resend_verification`
- `auth_request_password_reset`, `auth_reset_password`
- `upload_init`, `upload_chunk`, `upload_complete`, `upload_cancel`
- `ws_connect` — WebSocket connection info

**Step 2: Update version to 0.2.0**

Also update `version: '0.2.0'` in the MCP response.

**Step 3: Commit**

```bash
git add src/routes/mcp.routes.ts
git commit -m "feat: update MCP endpoint with v0.2.0 tools"
```

---

### Task 24: Update OpenAPI Version + Documentation

**Files:**
- Modify: `src/index.ts` — update API version to 0.2.0
- Modify: `package.json` — bump to 0.2.0
- Modify: `CHANGELOG.md` — add v0.2.0 entry

**Step 1: Bump version**

Update `package.json` version to `0.2.0`.
Update `src/index.ts` info version to `0.2.0`.

**Step 2: Add changelog entry**

**Step 3: Commit**

```bash
git add package.json src/index.ts CHANGELOG.md
git commit -m "chore: bump version to 0.2.0"
```

---

### Task 25: Final Validation

**Step 1: Run full validation suite**

```bash
npm run lint
npm run typecheck
npm run test:coverage
npm run build
```

Expected: All clean, all tests passing, coverage thresholds met, build succeeds.

**Step 2: Fix any issues found**

**Step 3: Final commit if needed**

```bash
git add -A
git commit -m "fix: address final validation issues for v0.2.0"
```

---

## Summary

| Wave | Tasks | Features |
|------|-------|----------|
| 1 | 1-6 | Error classes, crypto, validation middleware, RBAC, rate limiting, wiring |
| 2 | 7-10 | Pagination, query builder, user list endpoint, API versioning |
| 3 | 11-25 | User model update, auth schemas, email verification, password reset, upload (schema + service + routes), WebSocket (schema + manager + auth + handlers + routes), MCP update, versioning, final validation |

**Total:** 25 tasks, ~50+ test cases, 10 features.
